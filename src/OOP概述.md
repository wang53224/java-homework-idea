```java
在Java中，没有类就无法做任何事情。
```

## 类

+ 类（class) 是构造对象的模板或蓝图。由类构造对象的过程称为创建类的实例。

+ 对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。
+ 对于每个特定的对象都有一组特定的实例域值，这些值的集合就是这个对象的当前状态（state）。

### 类之间的关系

+ 依赖   uses-a  ：一个类的方法操纵另一个类的对象
+ 聚合   has-a：“关联”，一个类的对象包含另一个类的对象
+ 继承   is-a：表示特殊与一般的关系

注释：我们应该尽量将相互依赖的类减少，让类之间的耦合度最小。

### 自定义类

​	主力类（workhorse class），通常没有main方法，却有自己的实例域和实例方法。要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。

​	许多程序员习惯将每一个类存在一个单独的源文件中，若这样组织文件，将有两种编译源程序的方法。一种是使用通配符调用Java编译器，一种是直接键入命令：javac xxx.java。

​	可以用public标记实例域，但极为不提倡，破坏了封装性，强烈建议将实例域标记为 private。

​	类通常包括 类型属于某个类类型的实例域。实例域本身就是对象。

### final实例域

​	可以将实例域定义为fianl。构建对象时必须初始化这样的域，也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操纵中，不能够再对它进行修改。



## 对象

对象的三个主要特性：

+ 行为：behavior  可以对对象施加哪些操纵，可以对对象施加哪些方法。
+ 状态：state  当施加那些方法时，对象如何响应。
+ 标识：identity  如何辨别具有相同行为的行为与状态的不同对象。

### 构造

想要使用对象，就必须先构造对象，并指定其初始状态。然后再对对象应用方法。

在Java中，使用构造器（constructor）构建新实例。构造器是一种特殊的方法，用来构造并初始化对象。

构造器的名字应与类名相同，想要构建一个对象，要在构造器前加上new操作符。

+ 对象变量：不是一个对象，可以引用对象。没有实际包含一个对象，仅仅引用一个对象。局部变量不会自动地初始化为null,必须通过调用new或将它们设置为null进行初始化。
+ 构造器与其他方法一个很重要的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
+ 总结：
  + 构造器与类同名
  + 每个类可以有一个以上的构造器
  + 构造器可以有0个、1个或多个参数
  + 构造器没有返回值
  + 构造器总是伴随着new操纵一起调用
  + 不要在构造器中定义与实例域重名的局部变量，即不必加数据类型

### 重载

​	有些类有多个构造器，这种特征叫重载(overloading)。

​	有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。

​	如果编译器找不到对应的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载解析）

```java
注释：
    Java允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。
    这叫做方法的签名(signature)。例如，String类有4个称为 indexOf 的公有方法。
    它们的签名是：
    	indexOf(int)
    	indexOf(int, int)
    	indexOf(String)
    	indexOf(String, int)
```

+ 返回类型**不是**方法签名的一部分。
+ 也就是说，**不能**有两个名字相同、参数类型也相同却返回不同类型值的方法。

### 默认域初始化

​	如果在构造器中没有显式地给域赋予初值。那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。然而，这样做不好，如果不明确地对域进行初始化，就会影响代码的可读性。

```
注释：
	这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，但是如果没有初始化类中的域，将会被自动初始化为默认值（0,false,null）.
```

### 无参数的构造器

​		很多类都包含一个无参数的构造器，对象由无参数构造函数创建时，其状态会设置为适当的默认值。

```java
例如：
public Employee()
{
	name = "";
    salary = 0;
    hireDay = LocalDate.now();
}
```

+ 如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器。
+ 如果类中提供了至少一个构造器，但没有提供无参数构造器。那么在构造对象时，如果没有提供参数就会被视为**不合法**。

### 显式域初始化

​	通过重载类的构造方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎么调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。

+ 当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，可以在类定义中，直接将一个值赋给任何域。

  ```java
  class Employee
  {
      private String name = "";
      ......
  }
  ```

+ 初始值也不一定是常量值，也可以调用方法对域进行初始化。

  ```java
  class Employee
  {
      private static int nextId;
      private int id = assignId();
      ......
      private static int assignId()
      {
          int r = nextId;
          nextId++;
          return r;
      }
      .....
  }
  ```

+ 在C++中，不能直接初始化类的实例域。

### 关键字this

+ this指示隐式参数，也就是所构造的对象。

  ```java
  public Employee(String name, double salary){
      this.name = name;
      this.salary = salary;
  }
  ```

+ 调用同一个类的另一个构造器(用于构造器的第一个语句)

  ```java
  public Employee(double s)
  {
      // calls Empolyee(String, double)
      this("Employee #" + nextId ,s);
      nextId++;
  }
  
  ```

  这样对于公共的构造器代码部分只编写一次即可。

+ 在Java中，this引用等价于C++中的this指针。但是，在C++中，一个构造器**不能**调用另一个构造器。必须将抽取出的公共初始化代码编写成一个独立的方法。

### 初始化块

​	前面已经提到两种初始化数据域的方法：

+ 在构造器中设置值

+ 在声明中赋值

  ​	事实上，Java还有第三种机制---初始化块。在一个类的声明中，可以包含多个代码块。只有构造类的对象，这些块就会被执行。

  ```java
  class Employee
  {
      private static int nextId;
      
      private int id;
      private String name;
      private double salary;
      
      //object initialization block
      {
          id = nextId;
          nextId++;
      }
      
      public Employee(String aName, double aSalary)
      {
          name = aName;
          salary = aSalary;
      }
      
      public Employee()
      {
          name = "";
          salary = 0;
      }
      
      ......
  }
  
  //这个示例中，无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。
  //首先运行初始化块，然后才运行构造器的主体部分。
  ```

  + 这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。

### 调用构造器的处理步骤

1.  所有数据域被初始化为默认值（0、false、null）。
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。



## 静态域与静态方法

### 静态域

​	如果将域定义为 static ，每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。

​	例如，假定需要给每一个雇员赋予一个唯一的标识码。这里给Employee类添加一个实例域id和一个静态域nextID：

```java
class Employee
{
    private static int nextID = 1;
    private int id;
    ...
}
```

+ 现在，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextID。
+ 比如，假如有1000个Employee类的对象，则有1000个实例域id，但是只有一个静态域 nextID。即使没有一个雇员对象，静态域 nextID 也存在。
+ 静态域属于类，而不属于任何一个独立的对象。

```java
对静态域的初始化：
    可以提供一个初始化值，或者使用一个静态的初始化块来对静态域进行初始化。
    如果初始化代码比较复杂，那么使用静态初始化块：将代码放在一个块中，并标记关键字static。
    //static initialization block
static
{
	Radom generator = new Radom();
    nextId = generator.nextInt(10000);
}//将雇员ID的起始值赋予一个小于10000的随机整数
  在类第一次加载的时候，将会进行静态域的初始化。与实例域一样，除非将它们显式的设置成其他值，否则默认值为0，false或null。
   所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。
```

### 静态常量

​	静态变量使用得比较少，但静态常量却使用得比较多。例如，在Math类中定义的静态常量：圆周率  在程序中，可以使用`Math.PI`的形式获得这个常量。

```java
public class Math
{
	...
	public static final double PI = 3.14159265358979323846;
	...
}
```

### 静态方法

​	静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式`Math.pow(x,a)`会计算x的a次幂。在运算时，不使用任何Math对象，换句话说，**没有隐式的参数**。

​	可以认为静态方法是没有this参数的方法。

​	Empolyee类的静态方法，**不能**访问ID实例域，因为它不能操作对象。但是，静态方法**可以**访问自身类中的静态域。示例：

```java
public static int getNextID()
{
    renturn nextID;
}

//可以通过类名调用这个方法
int n = Employee.getNextID();

//也可以通过类的对象的引用调用这个方法，但是不建议
```

​	在下面两种情况下使用静态方法：

+ 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
+ 一个方法只需要访问类的静态域

```C
static的三个用法：
	1. C语言中，表示退出一个块后依然存在的局部变量
    2. C语言中，表示不能被其他文件访问的全局变量和函数
    3. C++,java中，表示属于类且不属于类对象的变量和函数
```

### main 方法

​	不需要使用对象调用静态方法，所以main方法也是一个静态方法，main方法不对任何对象进行操作。

​	事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需的对象。

 	每个类可以有一个main方法，这是一个常用于对类进行**单元测试**的技巧，以Employee类为例：

```java
class Employee
{
    public Employee(String n,double s, int year, int month, int day)
    {
        name = n;
        salay = s;
        LocalDate hireDay = LocalDate.now(year,month,day);
    }
    ...
    public static void main(String[] args)
    {
        Employee e = new Employee("Romeo",50000,2020,3,25);
        e.raiseSalary(10);
        System.out.println(e.getName() + " " + e.getSalary());
    }
    ...
}
/*
 *如果想独立的测试Employee类，只需要执行 java Employee
 *如果这是更大程序的一部分，只需要执行 java Application
 *Employee类的main方法永远不会执行
*/
```

## 方法参数

在程序设计语言中有关参数传递的专业术语：

+ **按值调用：**call by value 方法接收的是调用者提供的值
+ **按引用调用：**call by reference 方法接收的是调用者提供的变量**地址**
+ **按名调用：**call by name 如Algol这种古老的语言才使用，现已成为历史。

***一个方法可以修改传递引用所对应的变量值，不能修改传递值所对应的变量值。***



+ Java程序语言**总是**采用按**值**调用。也就是说，方法得到的是所有参数值的一个**拷贝**，特别是，方法不能修改传递给他的任何参数变量的内容。

  ```java
  public static void tripleValue(double x)	//doesn't work
  {
      x = 3 * x;
  }
  //调用这个方法
  double percent = 10;
  tripleValue(percent);
  //percent的值没变，还是10
  ```

  然而，方法参数共有两种类型：

  + 基本数据类型
  + 对象引用

  一个方法不能修改一个基本数据类型的参数。而对象引用作为参数就不同了，例如下面将雇员的薪金提高两倍：

```java
public static void increaseSalary(Employee x)	//works
{
    x.raiseSalay(200);
}
//当调用
harry = new Employee(...);
increaseSalary(harry);
//时，具体的执行过程为：
/*
1. X被初始化为harry值的拷贝，这里是一个对象的引用。
2. raiseSalay 方法应用于这个对象引用。x和harry同时引用的那个Employee对象的薪金提高了200%。
3. 方法结束后，参数变量x不再使用。当然，对象变量harry继续引用那个薪金增至3倍的雇员对象。
*/
```

即，对象引用是按值传递的。

+ Java中的方法参数的使用情况：
  + 一个方法不能修改一个基本数据类型的参数（数值型，布尔型）
  + 一个方法可以改变一个对象参数的状态
  + 一个方法不能让对象参数引用一个新的对象

## 包

​	Java允许使用包将类组织起来。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。

​	标准的Java类库分布在多个包中，具有层次结构。使用包的主要原因是确保类名的唯一性，为了保证包名的绝对唯一性，Sun公司建议将公司的域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包。从编译器的角度看，嵌套的包之间没有任何关系，例如：java.util包与java.util.jar包毫无关系，每一个都拥有独立的类集合。

### 类的导入

- 一个类可以使用**所属包**中所有的类，以及**其他包**中的公有类。

- 两种方式访问另一个包中的公有类

  - 在每一个类名前添加完整的包名

    ```java
    java.time.LocalDate today = java.time.LocalDate.now();
    ```

    这显然很麻烦

  - 使用import语句

    导入一个特定的类或者整个包，import语句应该位于源文件的顶部（位于package语句后）

    ```java
    import java.util.*;
    //导入java.uti包中所有的类
    
    //然后就可以使用
    LocalDate today = LocalDate.now();
    ```

- 但是，只能用星号导入一个包，而**不能**使用`import java.*`或`import java.*.*`导入以java为前缀的所有包。

### 静态导入

​	import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。

```java
import static java.lang.System.*;	//源文件顶部

//使用System类的静态方法和静态域
out.println("hahaha!");
exit(0);
```

### 将类放入包中

+ 要想将一个类放入包中，就必须将包的名字放在源文件的开头，包含类定义的代码前。

  ```java
  package com.google;
  
  public class Employee{
      ......
  }
  ```

+ 如果没有package语句，这个源文件中的类就会被放置在一个默认包中。

## 类设计技巧

1. 一定要保证数据私有
2. 一定要对数据初始化
3. 不要在类中使用过多的基本类型 
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解
6. 类名和方法名要能够体现它们的职责
7. 优先使用不可变的类

